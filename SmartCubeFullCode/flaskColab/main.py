# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p0TUsMnmXiWcTHz1ik1Bf_Ysf8b-azQC
"""

# üëá STEP 1: Install dependencies
!pip install flask flask-ngrok pyngrok fer opencv-python-headless cvlib --quiet
!apt install libglib2.0-0 libsm6 libxrender-dev libxext6 -y > /dev/null
!npm install -g localtunnel

from flask import Flask, request, jsonify
import cv2
import numpy as np
from fer import FER
import threading
from collections import deque, Counter
import cvlib as cv
import nest_asyncio
import subprocess
import time
import requests

nest_asyncio.apply()

app = Flask(__name__)
latest_mood = {"mood": ""}
lock = threading.Lock()
emotion_history = deque(maxlen=5)
detector = FER(mtcnn=True)
ALLOWED_EMOTIONS = {"happy", "sad", "angry", "neutral"}


def get_largest_face_cvlib(img):
    faces, confidences = cv.detect_face(img)
    if not faces:
        return None
    faces.sort(key=lambda box: (box[2] - box[0]) * (box[3] - box[1]), reverse=True)
    x1, y1, x2, y2 = faces[0]
    return img[y1:y2, x1:x2]


@app.route('/mood', methods=['POST'])
def detect_mood():
    try:
        image_bytes = request.data
        np_arr = np.frombuffer(image_bytes, np.uint8)
        img = cv2.imdecode(np_arr, cv2.IMREAD_COLOR)
        if img is None:
            return jsonify({"error": "Failed to decode image"}), 400
        img = cv2.resize(img, (640, 480))

        results = detector.detect_emotions(img)

        if results:
            results.sort(key=lambda r: r['box'][2] * r['box'][3], reverse=True)
            top_face = results[0]
            emotions = top_face['emotions']
            emotion, score = max(emotions.items(), key=lambda x: x[1])
            if emotion not in ALLOWED_EMOTIONS:
                emotion = "neutral"
            if score >= 0.6:
             # üî• High confidence: use raw emotion
                final_emotion = emotion
            else:
             # üåä Low confidence: use smoothing
                emotion_history.append(emotion)
                final_emotion = Counter(emotion_history).most_common(1)[0][0]

            with lock:
                latest_mood['mood'] = final_emotion

            print(f"[INFO] Detected: {emotion} (Confidence: {score:.2f}) ‚Üí Final: {final_emotion}")

        else:
            with lock:
                latest_mood['mood'] = ""
            print("[INFO] No emotion detected")

        return jsonify({"status": "success"}), 200

    except Exception as e:
        print(f"[ERROR] {str(e)}")
        return jsonify({"error": str(e)}), 500

@app.route('/get-mood', methods=['GET'])
def get_mood():
    with lock:
        return jsonify(latest_mood)

def run_flask():
    app.run(host='0.0.0.0', port=5000)

threading.Thread(target=run_flask).start()

!pkill lt || true
lt_process = subprocess.Popen(['lt', '--port', '5000', '--subdomain', 'dini-mood-box'])
time.sleep(5)

print("‚úÖ Your fixed LocalTunnel URL is:")
print("http://dini-mood-box.loca.lt")

try:
    res = requests.get("http://dini-mood-box.loca.lt/get-mood?client_id=test")
    if res.status_code in [200, 404]:
        print("‚úÖ LocalTunnel is LIVE and responding.")
    else:
        print("‚ö†Ô∏è Unexpected response code:", res.status_code)
except Exception as e:
    print("‚ùå LocalTunnel is not reachable.")
    print(e)

while True:
    print("üåÄ Keeping Colab alive...")
    time.sleep(60)